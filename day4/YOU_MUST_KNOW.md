# YOU_MUST_KNOW: Day 4 필수 개념 정리

## 1. `Vec<T>` — 같은 종류의 데이터를 모으는 기본 상자
- `Vec<T>`는 "Vector"의 줄임말로, 같은 타입의 값들을 순서대로 저장하는 성장형 배열입니다.
- 예를 들어 여러 피어 이름을 `Vec<String>`에 넣어 두면 `peers[0]`, `peers[1]` 처럼 순서대로 접근할 수 있습니다.
- 벡터는 필요할 때마다 뒤에 요소를 추가(`push`)하고, 마지막 요소를 제거(`pop`)할 수 있어 동적으로 크기가 변합니다.
- Rust에서는 벡터 안의 요소 타입이 모두 동일해야 하므로, 한 벡터에 `String`과 `u64`를 섞어 넣을 수 없습니다. 이 제약 덕분에 컴파일러가 메모리를 더 안전하게 관리합니다.

## 2. `for` 반복문과 슬라이스 참조
- `for item in &collection` 구문은 컬렉션을 차례차례 훑으면서 매 반복마다 요소를 빌려옵니다.
- `&collection`처럼 참조를 넘기면, 반복문 안에서 해당 요소를 읽을 수 있지만 소유권을 가져가지 않습니다. 그래서 다른 함수에서 같은 벡터를 계속 사용할 수 있습니다.
- 우리는 `&[NodePeer]` (피어 슬라이스)와 같은 형태로 함수를 정의했습니다. 슬라이스는 "벡터의 일부 또는 전체"를 가리키는 얇은 창문 같은 것이며, 복사 비용 없이 읽을 수 있게 해 줍니다.

## 3. `Option<T>`와 `if let`
- `Option<T>`는 어떤 값이 있을 수도(`Some(T)`), 없을 수도(`None`) 있음을 표현하는 열거형입니다.
- `if let Some(value) = maybe_value` 문장은 `maybe_value`가 `Some`일 때만 `value`를 꺼내어 블록 안에서 사용할 수 있게 해 줍니다. `None`인 경우에는 블록이 건너뛰어집니다.
- "관심 있는 경우만 간단히 처리하고 싶다"면 `if let`이 좋고, 모든 경우를 하나씩 다뤄야 한다면 `match`가 더 명확합니다.

## 4. 최소값 찾기의 기본 원리
- 여러 숫자 중 최소값을 찾으려면 "현재까지 가장 작은 값"을 기록해 두고, 새로운 값과 비교하면서 더 작으면 교체합니다.
- Rust에서는 `Option<&NodePeer>` 같은 형태로 "아직 아무것도 찾지 못했을 때"를 `None`으로 표현하고, 값을 찾으면 `Some(peer)`로 저장하면 됩니다.
- 매 반복마다 `match current { None => ..., Some(existing) => ... }` 식으로 분기하면 첫 요소 처리와 이후 비교 로직을 자연스럽게 나눌 수 있습니다.
- 참조(`&NodePeer`)만 저장하기 때문에, 실제 구조체를 복사하지 않아도 됩니다. 덕분에 가벼운 비용으로 최소값을 추적할 수 있습니다.

## 5. 문자열 포매팅으로 보고서 만들기
- `format!("{} synced up to slot {}", name, slot)`은 템플릿 문자열에 변수를 끼워 넣어 새로운 `String`을 만듭니다.
- 반복문에서 `format!`을 여러 번 호출해 `Vec<String>`으로 모으면, 사람이 읽기 쉬운 보고서 목록이 됩니다.
- 실제 현업에서는 이런 문자열이 로그, 모니터링 대시보드, 슬랙 알림 등으로 전달됩니다. 오늘 실습은 그 첫 단추를 꿰는 과정입니다.

## 6. 왜 이런 연습이 블록체인 코어 엔지니어에게 중요한가?
- 블록체인 노드는 항상 여러 피어의 상태를 감시하면서 빠르게 대응해야 합니다. 지연 시간이나 슬롯 정보를 요약해 표시하는 기능은 운영 안정성의 기본입니다.
- 반복문과 벡터를 능숙하게 다루면, 네트워크에서 들어오는 대량의 메시지를 정리해 이해하기 쉬운 형태로 바꾸는 자동화 도구를 만들 수 있습니다.
- 오늘 과제에서 다룬 `Option`, `Vec`, `for` 패턴은 나중에 더 복잡한 동시성 코드나 네트워크 프로토콜을 다룰 때도 계속 등장합니다. 기초를 정확히 잡아 두면 이후 학습 곡선이 훨씬 완만해집니다.
