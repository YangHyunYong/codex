# Day 4: 벡터와 반복문으로 미니 노드 대시보드 만들기

**난이도: EASY (가볍게 손 풀기 좋은 날!)**

## [전날 과제 요약]
- Day 3에서는 `match`로 모든 경우의 수를 빠짐없이 다루는 감각을 길렀습니다.
- `Option`과 `Result`를 사용해 "값이 없을 때"와 "오류가 났을 때"를 명시적으로 표현하는 법을 연습했습니다.
- 짧은 테스트 코드를 작성하고 `cargo fmt`, `cargo test` 루틴으로 마무리하는 습관을 들였습니다.

## [전날 과제로 얻은 역량]
- 여러 상태를 패턴 매칭으로 펼쳐 놓고 안전하게 분기 처리하는 능력을 갖췄습니다.
- 실패를 숨기지 않고 기본값이나 메시지로 부드럽게 되돌리는 에러 핸들링 감각을 익혔습니다.
- 테스트 주도 접근의 첫걸음으로, 원하는 결과를 미리 정의한 뒤 구현을 채워 넣는 리듬을 느꼈습니다.

## [오늘 과제 목표]
- `Vec<T>`와 `for` 반복문으로 여러 데이터를 순회하며 요약 정보를 만드는 연습을 합니다.
- `if let`과 `match`를 섞어 써서 조건부로만 관심 있는 값을 뽑아내는 패턴을 익힙니다.
- 간단한 구조체를 정의하고 구조체 벡터를 순회하며 레포트를 만드는 흐름을 경험합니다.

## [오늘 과제 설명]
오늘은 "노드 모니터링 대시보드"의 아주 축소된 버전을 만들어 보겠습니다. 실제 블록체인 노드는 수십 개의 피어를 추적하지만, 우리는 네댓 개만 다루면서 반복과 요약의 기본기를 쌓습니다.

1. **새 프로젝트 만들기**
   - `cargo new day4_node_dashboard --lib` 명령으로 라이브러리 프로젝트를 생성합니다.
   - Day 3에서와 마찬가지로 `src/lib.rs`가 핵심 구현을 담고, `tests` 디렉터리에 통합 테스트를 둘 예정입니다.

2. **피어 상태를 담는 구조체 정의하기** (`src/lib.rs`)
   - `NodePeer` 구조체를 만들고 아래 필드를 정의합니다.
     - `pub name: String` — 피어의 이름입니다.
     - `pub last_slot: Option<u64>` — 마지막으로 보고된 슬롯 번호입니다. 아직 블록을 못 받은 피어라면 `None`입니다.
     - `pub latency_ms: u64` — 왕복 지연 시간입니다.
   - 구조체 위에는 "왜 이런 정보를 모으는지"를 어린이에게 설명하듯 한국어+영어로 짧게 적어 주세요.

3. **요약 함수 작성하기** (`src/lib.rs`)
   - 아래 함수를 순서대로 구현합니다. 각 함수 위에도 주석을 남겨 "이 함수가 어떤 문제를 해결하는지" 설명합니다.
     1. `pub fn count_uninitialized(peers: &[NodePeer]) -> usize`
        - `last_slot`이 `None`인 피어가 몇 개인지 세어 반환합니다.
        - `for` 반복문과 `if let`을 활용해 보세요.
     2. `pub fn fastest_peer<'a>(peers: &'a [NodePeer]) -> Option<&'a NodePeer>`
        - 지연 시간이 가장 낮은 피어에 대한 참조를 반환합니다.
        - 피어가 하나도 없다면 `None`을 반환합니다.
        - 최소값을 갱신할 때는 `match`나 `if let`으로 현재까지 찾은 피어를 비교해 주세요.
     3. `pub fn summarize_slots(peers: &[NodePeer]) -> Vec<String>`
        - 각 피어를 순회하며 아래 규칙에 맞는 설명 문장을 만들어 `Vec<String>`으로 모읍니다.
          - 슬롯을 알고 있는 경우: `format!("{} synced up to slot {}", name, slot)`
          - 슬롯을 모르는 경우: `format!("{} awaiting first block", name)`
        - 이 함수는 "여러 값 -> 보고용 문자열" 패턴을 반복하며 익숙해지는 것이 목적입니다.

4. **테스트 작성하기** (`tests/dashboard.rs`)
   - 아래 시나리오를 검증하는 통합 테스트를 작성합니다. 각 테스트 위에는 테스트 목적을 주석으로 명시하세요.
     - `count_uninitialized`가 초기화되지 않은 피어 수를 정확하게 센다.
     - `fastest_peer`가 최소 지연 시간을 가진 피어를 찾아 준다. 피어가 없을 때 `None`을 돌려준다는 케이스도 포함합니다.
     - `summarize_slots`가 슬롯이 있는 피어와 없는 피어를 구분해 예상 문장을 만든다. 벡터 길이와 각 항목 문자열을 모두 확인하세요.

5. **마무리 루틴**
   - `cargo fmt`와 `cargo test`를 실행하며 코드 정리 및 동작 검증 루틴을 반복합니다.
   - README 맨 아래에 학습자가 느낀 점을 자유롭게 적을 수 있는 "오늘의 TIL" 섹션을 남겨 주세요.

## [이해를 돕기 위한 예시]
아래 예시는 `if let`을 써서 `Option`에서 값이 있는 경우만 처리하는 패턴입니다. 오늘 과제에서도 `None`과 `Some`을 구분하는 데 이 구조를 사용하게 됩니다.

```rust
fn print_last_slot(slot: Option<u64>) {
    if let Some(value) = slot {
        println!("Last known slot: {value}");
    } else {
        println!("No slot yet, still waiting...");
    }
}
```

- `if let`은 특정 패턴과 맞는 경우에만 블록을 실행합니다. `match`보다 간결해서, 한 가지 경우만 관심 있을 때 자주 씁니다.
- 벡터(`Vec<T>`)는 같은 타입의 데이터를 순서대로 저장하는 컨테이너입니다. 반복문과 함께 사용하면 여러 피어의 상태를 한꺼번에 훑는 데 유용합니다.
- 오늘 만든 요약 함수들은 이후 "실제 노드에서 수집한 메트릭을 사람이 읽을 수 있는 문장으로 바꾸기" 같은 작업의 기초가 됩니다.

---

### 오늘의 TIL (Today I Learned)
- (학습자가 자유롭게 작성할 공간)
