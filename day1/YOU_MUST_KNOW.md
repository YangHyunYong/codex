# YOU_MUST_KNOW

러스트에서는 변수 하나를 선언하는 것도 프로그램 전체의 안전성과 성능을 좌우합니다. 아래 내용을 꼭 이해한 뒤 과제를 진행하세요.

## 1. 불변 변수와 가변 변수
- 러스트에서 `let x = 3;`라고 쓰면 기본적으로 **불변 변수(immutable variable)**가 만들어집니다. 즉, 이후에 `x = 4;`처럼 값을 바꾸려고 하면 컴파일 오류가 발생합니다.
- 값을 바꿔야 한다면 `let mut x = 3;`처럼 `mut` 키워드를 추가해 **가변 변수(mutable variable)**로 선언해야 합니다.
- 왜 기본이 불변일까요? 많은 버그가 예상치 못한 값 변경에서 나오기 때문에, 러스트는 개발자가 의도를 명확히 표현하도록 강제합니다.

## 2. 상수(const)와 가변 변수의 차이
- `const MAX_POINTS: u32 = 100_000;`처럼 `const`로 선언하면 프로그램 전역에서 사용할 수 있는 변하지 않는 값을 만들 수 있습니다.
- `const`는 항상 타입을 명시해야 하고, 컴파일 타임에 결정되는 값만 담을 수 있습니다.
- 가변 변수는 런타임에 바뀔 수 있지만, 상수는 절대로 바뀌지 않습니다. 시스템 프로그래밍에서는 하드웨어 레지스터 주소 같은 값을 담을 때 유용합니다.

## 3. 섀도잉(Shadowing)
- 같은 이름의 변수를 다시 선언하면, 이전 변수는 사라지고 새 변수가 등장한 것처럼 동작합니다.
- 예: `let score = 10; let score = "A";` → 두 번째 `score`는 문자열 타입이지만, 첫 번째 `score`는 더 이상 사용할 수 없습니다.
- 재할당(`score = 11;`)과 섀도잉은 다릅니다. 재할당은 같은 변수를 가리키지만 값만 바뀌고, 섀도잉은 **새 변수가 같은 이름으로 덮어씌워지는 것**입니다.

## 4. 소유권(Ownership)과 이동(Move)
- 러스트는 메모리 안전을 위해 **소유권** 규칙을 사용합니다. 어떤 값은 반드시 하나의 소유자(owner)를 가져야 합니다.
- `let s1 = String::from("hi"); let s2 = s1;`라고 하면 문자열의 소유권이 `s1`에서 `s2`로 이동(move)합니다.
- 이동 후에는 `s1`을 더 이상 사용할 수 없고, 사용하려 하면 컴파일 오류가 발생합니다. 덕분에 이중 해제(double free) 같은 메모리 오류가 원천 차단됩니다.

## 5. 테스트로 개념을 굳히는 법
- `#[cfg(test)]` 모듈이나 `tests/` 디렉토리를 활용하면 함수가 의도한 대로 동작하는지 자동으로 검사할 수 있습니다.
- 예를 들어 `assert_eq!(describe_mutability().contains("mut"), true);` 같은 테스트는 함수가 필요한 설명을 담고 있는지 확인해 줍니다.
- 블록체인 코어 엔지니어링에서는 작은 개념 실수도 큰 보안 사고로 이어질 수 있으므로, 습관적으로 테스트를 작성하는 것이 매우 중요합니다.

이 다섯 가지 개념을 어린 학생에게 설명할 수 있을 정도로 명확하게 이해하면, 이후 소유권, 수명(lifetime), 동시성 같은 고급 주제를 학습할 준비가 됩니다.
