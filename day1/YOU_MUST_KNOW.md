# Day 1 YOU_MUST_KNOW (난이도: EASY)

## Rust 도구 체인의 구성
- **rustup**: 여러 버전의 Rust 컴파일러와 표준 라이브러리를 손쉽게 설치하고 전환해 주는 관리 도구입니다. `rustup update`를 실행하면 최신 안정 버전을 내려받습니다.
- **cargo**: Rust의 빌드 시스템이자 패키지 관리자입니다. `cargo new`로 프로젝트를 만들고, `cargo build`, `cargo test`, `cargo run`으로 각각 컴파일, 테스트, 실행을 진행합니다. Cargo는 `Cargo.toml` 파일을 읽어 의존성과 메타데이터를 파악합니다.
- **rustc**: 실제로 코드를 기계어로 바꾸는 컴파일러입니다. 보통 직접 사용할 일은 적지만, Cargo 내부에서 rustc를 호출합니다.

## 소유권과 빌림(Ownership & Borrowing)
- Rust는 메모리 안전성을 위해 "이 값은 누가 관리하나요?"를 컴파일 타임에 항상 추적합니다. 이를 **소유권**이라고 합니다.
- 어떤 값의 소유권은 한 번에 하나의 변수만 가질 수 있고, 소유권이 이동(move)하면 이전 변수는 더 이상 그 값을 사용하지 못합니다.
- 값을 잠깐 빌려 쓰고 싶다면 **참조(reference)** 를 사용합니다. `&T`는 읽기 전용, `&mut T`는 읽고 수정할 수 있습니다. 동시에 가질 수 있는 참조의 수에 제한이 있어 데이터 경쟁을 막아 줍니다.

## Result와 에러 처리
- Rust에서는 오류가 날 수 있는 작업이 `Result<T, E>` 타입을 반환하는 것이 일반적입니다. `Ok(T)`는 성공을, `Err(E)`는 실패를 표현합니다.
- `match` 표현식이나 `?` 연산자를 이용해 오류를 우아하게 전파할 수 있습니다.
- CLI 프로그램에서는 잘못된 인자를 받았을 때 `Err`를 반환하고, 사용자에게 무엇이 잘못되었는지 설명하는 메시지를 보여 주도록 설계해야 합니다.

## 테스트 주도 개발(TDD) 사이클
1. **Red**: 실패하는 테스트를 먼저 작성한다. 아직 구현이 없으니 테스트가 실패해야 정상입니다.
2. **Green**: 테스트를 통과시키는 최소한의 코드를 작성한다. 과도한 기능은 뒤로 미룹니다.
3. **Refactor**: 테스트가 모두 초록색이 된 상태에서 코드 품질을 개선한다. 구조를 다듬고 중복을 제거합니다.
- 이 과정을 반복하면서 기능을 확장하면, 항상 테스트가 안전망 역할을 해 줍니다.

## CLI 프로그램 구조화 팁
- **main 함수는 얇게**: 실제 비즈니스 로직을 라이브러리(`src/lib.rs`)에 배치하면 테스트가 쉬워집니다.
- **입력 파싱과 계산 로직 분리**: 사용자 입력을 구조체나 enum으로 파싱한 뒤, 변환 함수에 전달하세요. 이렇게 하면 입력 형식이 바뀌어도 계산 로직을 수정하지 않아도 됩니다.
- **포맷팅과 국제화**: 출력 문자열을 구성할 때 온도 단위를 명확히 표기하고, 소수점 자릿수를 통제하면 사용자 경험이 좋아집니다.

## 컴퓨터 공학 연결 고리
- 온도 변환은 간단하지만, 부동소수점 연산을 다루게 됩니다. IEEE 754 규격에서 `f64`가 제공하는 정밀도 한계를 이해하면 왜 `abs() < f64::EPSILON`으로 비교하는지 알 수 있습니다.
- CLI 입력은 결국 프로세스의 표준 입력과 명령줄 인자를 다루는 작업입니다. 운영체제가 프로그램을 실행할 때 어떻게 인자를 전달하는지 조사해 보면 시스템 프로그래밍의 기초를 다질 수 있습니다.
