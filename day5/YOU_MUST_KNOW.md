# Day 5 YOU MUST KNOW

오늘 과제를 수행하면서 반드시 이해해야 할 컴퓨터 공학 지식을 14살 어린이도 이해할 수 있는 수준으로 설명합니다. 동시에, 실제 업무에 투입될 때 유용하도록 실무적인 디테일도 포함합니다.

## 1. 멤풀(Mempool)이란?
- **어린이 버전**: 블록체인에 거래(트랜잭션)를 올리려면 먼저 줄을 서야 해요. 이 줄 서 있는 대기실이 바로 멤풀입니다. 친구들이 놀이기구를 기다릴 때 순서를 지키는 것처럼, 트랜잭션들도 멤풀에서 차례를 기다립니다.
- **실무 디테일**: 실제 노드는 네트워크로부터 받은 트랜잭션을 검증한 뒤 멤풀에 넣습니다. 수수료가 높거나 최근에 시뮬레이션을 통과한 트랜잭션이 우선순위가 높습니다. 멤풀 관리가 느슨하면 DoS 공격이나 스팸에 취약해져 블록 생성이 지연될 수 있습니다.

## 2. 구조체(Struct)와 열거형(Enum)
- **어린이 버전**: 구조체는 서로 관련 있는 데이터를 한 덩어리로 묶는 상자예요. 열거형은 여러 가지 상태 중 하나만 선택하는 스위치입니다.
- **실무 디테일**: `PendingTx` 구조체에 트랜잭션의 다양한 속성을 담고, `TxStatus` 열거형으로 현재 상태를 표현합니다. 이렇게 하면 함수에 인자로 전달할 때 타이핑 실수를 줄이고, 코드가 어떤 상태를 기대하는지 명확해집니다.

## 3. 트레이트(Trait)
- **어린이 버전**: 트레이트는 "이 능력을 가진 친구만 들어오세요"라고 조건을 거는 입구입니다. `MempoolFilter` 트레이트를 만족하는 친구들만 필터 역할을 할 수 있어요.
- **실무 디테일**: 트레이트를 이용하면 서로 다른 필터 전략을 쉽게 갈아 끼울 수 있습니다. 테스트에서는 간단한 더미 필터를 만들어 원하는 케이스를 검증하고, 실제 서비스에서는 복잡한 정책을 적용할 수 있습니다.

## 4. 라이프타임(Lifetime)과 참조(Reference)
- **어린이 버전**: 참조는 "이 장난감은 내 것이 아니지만 잠깐 빌려볼게"라고 말하는 것과 같아요. 빌린 장난감을 원래 주인이 치워 버리면 곤란하니, 언제까지 빌릴 수 있는지 약속(라이프타임)을 해야 합니다.
- **실무 디테일**: `filter_transactions`는 원본 벡터의 요소를 복사하지 않고 참조로 반환합니다. 이렇게 하면 대량의 데이터를 처리할 때 메모리를 절약할 수 있습니다. 대신, 원본 데이터가 유효한 동안에만 참조를 사용할 수 있다는 것을 컴파일러에게 알려 주어야 합니다.

## 5. `BTreeMap`의 정렬 특성
- **어린이 버전**: `BTreeMap`은 자동으로 사전순으로 정리해 주는 정리함입니다. 이름이 "가", "나", "다" 순서대로 정리돼 있어요.
- **실무 디테일**: `BTreeMap`은 키가 정렬돼 있어 리포트를 출력할 때 순서가 안정적입니다. 블록체인 모니터링 시스템에서는 로그나 메트릭을 일정한 순서로 보여 주어야 디버깅이 쉬워집니다. 반면 `HashMap`은 순서가 없으므로 출력이 매번 달라질 수 있습니다.

## 6. 패턴 매칭과 상태별 처리
- **어린이 버전**: `match`는 여러 가지 경우를 하나씩 확인하는 체크리스트입니다. "Pending이면 파란색 스티커, Rejected면 빨간색 스티커"처럼요.
- **실무 디테일**: 트랜잭션 상태에 따라 다른 통계를 계산해야 할 때 `match`를 사용하면 깔끔합니다. 나중에 `TxStatus`에 새로운 변형이 추가되면 컴파일러가 모든 매치를 업데이트하라고 알려 줍니다.

## 7. 개발 루틴 자동화
- **어린이 버전**: 매번 숙제를 끝낼 때 공책을 정리하고, 틀린 문제가 없는지 확인하는 습관을 들이는 것과 같아요.
- **실무 디테일**: `cargo fmt`, `cargo clippy`, `cargo test`를 순서대로 돌리는 것은 실제 회사에서도 지켜야 할 기본 개발 루틴입니다. 포맷터는 코드 스타일을 통일하고, 클리피는 잠재적인 버그를 경고해 주며, 테스트는 기능이 의도대로 동작하는지 확인합니다.
