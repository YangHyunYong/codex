# Day 2: 소유권과 빌림으로 안전한 데이터 흐름 설계하기

**난이도: EASY**

## [전날 과제 요약]
- `day1_variables` 라이브러리에서 변수의 가변성, 섀도잉, 소유권 이동을 설명하고 테스트로 검증했습니다.

## [전날 과제로 얻은 역량]
- 불변/가변 변수 선언 패턴을 구분하고, 섀도잉과 소유권 이동(move)에 대한 기본 개념을 코드와 테스트로 증명하는 습관을 익혔습니다.

## [오늘 과제 목표]
- 러스트의 빌림(borrowing) 규칙과 참조(reference) 개념을 함수 단위로 적용할 수 있다.
- 가변 참조와 불변 참조의 충돌 조건을 이해하고, 테스트를 통해 안전한 사용법을 검증한다.
- 슬라이스(slice)와 소유권이 어떻게 상호작용하는지 체험한다.

## [오늘 과제 설명]
1. `cargo new day2_ownership --lib` 명령으로 새로운 라이브러리 프로젝트를 생성하세요.
2. `src/lib.rs`에 다음 기능을 구현하세요.
   - `pub fn annotate_borrowing(message: &str) -> String`: 입력 문자열을 차용만 하는 함수로, 불변 참조가 안전한 이유를 설명하는 다중 라인 문자열을 반환합니다. 반환 문자열에는 최소한 "immutable reference"와 "no data race"라는 표현을 포함하세요.
   - `pub fn mutate_wallet(balance: &mut i64, delta: i64)`: 가변 참조를 받아 잔액을 수정합니다. 함수 내부에서 가변 빌림이 단일 스코프에서만 허용됨을 주석과 로직으로 보여 주세요. 음수 잔액이 될 경우 `panic!` 대신 `Result<(), String>`을 사용하여 오류 메시지를 반환하도록 하세요.
   - `pub fn summarize_slice<'a>(blocks: &'a [u64]) -> (&'a [u64], usize)`: 블록 높이 목록을 슬라이스로 받아, 앞부분 3개의 요소만 가리키는 서브 슬라이스(3개 미만이면 가능한 만큼)와 총 요소 수를 함께 반환합니다.
3. `tests/borrowing.rs` 파일을 만들어 다음을 검증하세요.
   - `annotate_borrowing` 결과가 원본 문자열을 소비하지 않고, 필수 키워드를 포함하는지 테스트하세요.
   - `mutate_wallet`이 정상적인 증감과 음수 잔액 방지 로직을 올바르게 처리하는지 `Result` 비교로 검증하세요.
   - `summarize_slice`가 슬라이스 참조를 복사 없이 공유한다는 것을 보여 주기 위해, 원본 배열 값을 변경하면 반환된 슬라이스에도 반영되는지 테스트하세요.
4. 모든 함수와 테스트에는 소유권(ownership), 빌림(borrowing), 수명(lifetime) 용어를 한/영 병기하고, 블록체인 노드 상태 업데이트에 어떤 이점이 있는지 한 줄 이상의 주석으로 연결해 주세요.
5. `cargo fmt`와 `cargo test`를 실행하여 코드 스타일과 테스트가 통과함을 확인하세요.
6. README 마지막에는 학습자가 오늘 배운 내용을 기록할 수 있도록 짧은 학습 일지 섹션을 남겨 두세요.

## [이해를 돕기 위한 예시]
```rust
pub fn share_balance(balance: &i64) {
    println!("현재 잔액은 {}입니다", balance); // 불변 참조(immutable reference)는 동시에 여러 개 존재해도 안전합니다.
}

pub fn apply_fee(balance: &mut i64) {
    *balance -= 1; // 가변 참조(mutable reference)는 동시에 하나만 허용되어 데이터 경합(data race)을 막습니다.
}
```
- 위 예시는 같은 데이터를 읽기 전용으로 여러 번 참조하거나, 단 한 번의 가변 참조를 통해 안전하게 수정하는 패턴을 보여 줍니다.
- 과제에서는 이러한 개념을 실제 함수와 테스트로 검증하여 블록체인 상태 업데이트 로직에 적용할 준비를 하게 됩니다.

---

### 학습자 학습 일지 메모
- (학습자가 작성할 공간)
