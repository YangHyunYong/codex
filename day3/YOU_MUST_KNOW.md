# Day 3 YOU MUST KNOW

## `match` 표현식은 왜 안전할까?
Rust의 `match`는 모든 가능한 경우를 반드시 다뤄야만 컴파일이 됩니다. 어린 학생이 수학 문제를 풀 때 답안지를 끝까지 채우지 않으면 선생님이 틀렸다고 표시하는 것과 같습니다. 덕분에 프로그램은 빠뜨린 경우 없이 동작하고, 우리가 놓친 예외 상황도 미리 잡아낼 수 있습니다.

## `Option<T>`: 값이 없을 수도 있음을 표현하는 상자
- `Some(value)`는 상자 안에 값이 있음을 뜻합니다.
- `None`은 상자가 비어 있다는 의미입니다.
블록체인 검증 노드는 항상 새 슬롯이 생기는 것이 아니기 때문에, 슬롯 정보가 비어 있을 수도 있습니다. `Option` 타입을 사용하면 이런 상황을 코드에서 자연스럽게 다룰 수 있고, 실수로 빈 값을 그대로 사용해 버리는 사고를 막아줍니다.

## `Result<T, E>`: 성공 또는 실패를 한눈에 구분하기
- `Ok(value)`는 작업이 성공했음을 의미합니다.
- `Err(error)`는 실패했음을 알려줍니다.
네트워크에서 블록 높이를 가져오다 보면, 연결이 잠깐 끊겨 실패할 때가 있습니다. `Result`는 이런 실패를 숨기지 않고 겉으로 드러내 주기 때문에, 운영자가 어떤 조치를 취해야 하는지 판단하기 쉬워집니다.

## 기본값과 경계값을 미리 정해 두기
성능 지표(예: 지연 시간)는 숫자만 보고 해석하기 어렵습니다. "100ms 이하면 빠르다"처럼 기준을 정해 놓으면, 경보를 자동으로 만들 수 있습니다. 이런 기준을 정한 뒤에는 테스트로 경계값을 확인해 두어야 나중에 코드가 바뀌어도 기준이 깨지지 않습니다.

## 왜 이것이 블록체인 코어 엔지니어에게 중요할까?
블록체인 코어 엔지니어는 네트워크 상태를 실시간으로 파악하고, 문제가 생기면 즉시 대응해야 합니다. `match`, `Option`, `Result`를 익숙하게 다루면, 복잡한 상태를 짧고 명확한 코드로 정리할 수 있습니다. 이는 곧 알람 시스템과 모니터링 대시보드를 설계할 때 큰 장점이 됩니다.
