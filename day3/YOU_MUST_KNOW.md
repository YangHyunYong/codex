# Day 3 YOU MUST KNOW

## `match` 표현식은 왜 든든한가요?
선생님이 시험지에서 모든 보기(A, B, C, D)를 다 확인해야 정답으로 인정하는 것과 비슷합니다. `match`도 가능한 경우를 전부 적어야 해서, 빠뜨린 상황이 있으면 컴파일러가 "이 부분 비었어요!" 하고 알려줍니다. 그래서 실수로 예외 상황을 놓칠 걱정이 크게 줄어듭니다.

## `Option<T>`: 값이 없을 수도 있다는 정직한 약속
- `Some(value)`: 상자 안에 값이 있어요.
- `None`: 상자가 텅 비었어요.
블록체인 노드가 아직 블록을 받지 못했을 때처럼, 값이 없을 수도 있는 상황을 자연스럽게 표현합니다. 파이썬의 `None`, 자바스크립트의 `undefined`와 비슷하지만, Rust에서는 반드시 이 경우를 처리해야 하기 때문에 더 안전합니다.

## `Result<T, E>`: 성공과 실패를 한눈에 구분하기
- `Ok(value)`: 일이 잘 끝났어요.
- `Err(error)`: 문제가 생겼어요.
네트워크 요청이 실패하면 그냥 프로그램이 멈추는 대신, `Result`를 통해 "어떤 에러였는지"를 기록하거나 기본값으로 대체할 기회를 얻습니다. 실무에서는 로그를 남기거나 재시도할지 판단하는 기반이 됩니다.

## 범위 패턴 사용법
`0..=150`처럼 쓰면 0 이상 150 이하를 포함합니다. `151..=400`처럼 쓰면 151에서 400까지입니다. 숫자 구간을 눈으로 읽기 쉬워서, 조건문이 길어지는 것을 막아 줍니다.

## 오늘 내용이 블록체인 코어 엔지니어에게 주는 힘
블록체인 코어 엔지니어는 네트워크 상태를 계속 감시해야 합니다. 상태가 빠르게 변하기 때문에 "값이 없어도 안전하게 처리"하고 "실패가 나와도 바로 대응"하는 능력이 필수입니다. `match`, `Option`, `Result`는 이런 상황을 표현하는 가장 기본적인 도구입니다. 오늘 만든 작은 함수 세 개가 나중에는 거대한 모니터링 시스템의 밑바탕이 될 수 있다고 상상해 보세요!
